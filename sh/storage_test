#!/bin/sh -e
VERSION=0.6

cd /
cat t:mem | lzma -c -d | cpio -iumd
cat t:hdd | lzma -c -d | cpio -iumd


export PATH="$PATH:/usr/local/bin"

SAVED_TRAPS="$(trap)"

storage_test_sigstop()
{
	rc="$?"
	set +x
	set +e

	[ -z "$ipid" ] || kill -9 "$ipid" >/dev/null 2>&1 ||:
	[ -z "$tpid" ] || kill -9 "$tpid" >/dev/null 2>&1 ||:
	[ -z "$fpid" ] || kill -9 "$fpid" >/dev/null 2>&1 ||:

	killall inotifywait >/dev/null 2>&1 ||: 
	killall fio >/dev/null 2>&1 ||: 
	killall badblocks >/dev/null 2>&1 ||: 
	
	rm -rf $fpid_file $ipid_file $tpid_file ||:

	eval "$SAVED_TRAPS"

	[ "$rc" = "0" ] || false
}

trap storage_test_sigstop USR1 KILL TERM EXIT QUIT INT 

usage()
{
cat - >&2 <<EOF
-a|--functional-test; Select test type: bad-bloks for search all devices for bad blocks; fio for check I/O problems on HBA/DAS.
-D|--device-list FIO parameter; Set types of configurations in which disk system will be configured; May be disk; raid0; raid6, etc. When disk storage consist of more than 24 HDD, disks groups by 20 HDD per raid.
-M|--method-list  FIO parameter; Set type(method) of disks operations, there are: random, sequential
-m|--mode-list   FIO parameter; Set mode of work with storage, there are: read, write, readwrite
-d|--io-depth   FIO parameter; Depth of I/O operations;
-t|--test-duration   FIO parameter; Duration of the test in seconds;
-n|--disks-num   Right number of disks in storage;
-h|--max-hdd-temp  Set the value of maximum temperature of disks trigger;
-l|--max-latency  Set the value of maximum latency in disks operations, microseconds;
-I|--min-iops  Set the value of minimum IOPS in disks operations, trigger;
-b|--min-bandwidth  Set the value of minimum bandwidth in disks operations, KB/s;
-A|--all-disks !!!DANGEROUS!!! Run test on all disks (include system);
-F|--flush-storage !!!DANGEROUS!!! Erease storage configuration.
EOF
  exit 1
}


API_URL=""
logfile=/var/log/storage-test.$$
tmp_dir=/tmp/storage-test.$$
bad_disks_list=$tmp_dir/bad-disks-list
bad_block_list=$tmp_dir/bad-block-list
ipid_file=/var/run/inotifywait.pid
jpid_file=/var/run/fio-jobs.pid
fpid_file=/var/run/storage-test.pid
tpid_file=/var/run/temp-hdd-check.pid
srv_id=$(cat /tmp/srv_id 2>/dev/null ||:)

TEMP=`getopt -o a:D:h:M:m:d:t:n:l:I:b:AF --long apply-test:,device-list:,max-hdd-temp:,method-list:,mode-list:,io-depth:,test-duration:,disks-num:,max-latency:,min-iops:,min-bandwidth:,all-disks,flush-storage -n "t:storage" -- "$@" || echo  "t:storage: Wrong parameters"`

eval set -- "$TEMP"

bad_blocks_check=1
device_list=disk
method_list=seq
mode_list='read,write'
all_disks_flag=1

# Num of similtuosly disk tests
dev_group_dim_seq=4
dev_group_dim_rand=10

stor_test_time=120
sys_test_time=300

# Defait FIO configuration
block_size=8k
buffered=0
direct=1
io_engine=libaio

io_seq_depth=1
io_ran_depth=16
test_duration=360

# Critical SMART parameters
max_pend=10    # Maximum Pending sectors
max_offunc=10  # Maximum Offline UNC errors
max_revent=10  # Maximim Realloceted events
max_hdd_rsect=3    # Maximim Reallocated sectors (Bad blocks) for HDD
max_ssd_rsect=20    # Maximim Reallocated sectors (Bad blocks) for SSD
max_read_err=1 # Maximum Rear Raw errors (for WD and Hitachi only)


# Critical preformance constants
max_hdd_temp=55
warn_hdd_temp=50

# Critical FIO parameters
# for single disk
ref_stor_disks_num=15

ref_iops_rand_single=50
ref_latency_rand_read_single=20000
ref_latency_rand_write_single=20000
ref_bandwidth_seq_single=100000

# for system disks only
ref_iops_sys=50
ref_latency_read_sys=185000
ref_latency_write_sys=10000
ref_bandwidth_sys=350000

# for summary
ref_iops_all=50
ref_latency_read_all=100000
ref_latency_write_all=10000
ref_bandwidth_all=5000


while :; do
    case "$1" in
		-a|--apply-test) shift
				case "$1" in
				fio|badblocks) ;;
				*) echo  "t:storage: unknown test: $1" ;;
				esac
				opt_tests="${opt_tests:+$opt_tests,}$1"
				;;
		-D|--device-list) shift
				device_list=$1
				;;
		-h|--max-hdd-temp) shift
				max_hdd_temp=$1
				;;
		-M|--method-list) shift
        case "$1" in
        rand|seq) method_list=$1 ;;
        *) echo  "t:storage: unknown method: $1" ;;
				esac
				;;
		-m|--mode-list) shift
        case "$1" in
        read|write|readwrite|read,write) mode_list=$1 ;;
        *) echo  "t:storage: unknown method: $1" ;;
				esac
				;;
		-d|--io-depth) shift
				io_seq_depth=$1
				io_ran_depth=$1
				;;
		-t|--test-duration) shift
				opt_test_duration=$1
				;;
		-n|--disks-num) shift
				ref_stor_disks_num=$1
				;;
		-l|--max-latency) shift
				ref_latency=$1
				;;
		-I|--min-iops) shift
				ref_iops=$1
				;;
		-b|--min-bandwidth) shift
				ref_bandwidth=$1
				;;
		-A|--all-disks)
				all_disks_flag=1
				;;
		-F|--flush-storage)
				flush_storage_conf_flag=1
				;;
    --) shift
        break
        ;;
		*) echo  "t:storage: Unimplemented option chosen: $1"
        ;;
		esac
		shift
done

[ -n "$opt_tests" ] || opt_tests=fio
[ -z "$opt_test_duration" ] || test_duration=$opt_test_duration
opt_tests="$(printf $opt_tests | tr ',' ' ')"
mode_list="$(printf $mode_list | tr ',' ' ')"
method_list="$(printf $method_list | tr ',' ' ')"

mkdir -p $tmp_dir

stor_disks=$(lsscsi -tg | grep sas | sed -n 's,.*\(/dev/sd[a-z]*\) .*,\1,p')
[ -n "$stor_disks" ] && stor_disks_num=$(printf "$stor_disks\n" | wc -l)
sys_disks=$(lsscsi | grep -vE 'sas|AMI|cd' | sed -n 's,.*\(/dev/sd[a-z]\).*,\1,p')
[ -n "$sys_disks" ] && sys_disks_num=$(printf "$sys_disks\n" | wc -l)

[ ! -n "$stor_disks" -a ! -n "$sys_disks" ] && echo "t:storage: WARNING! No disks found at all"

[ -n "$all_disks_flag" ] && test_disk_list="$(printf "$sys_disks\n$stor_disks")" || test_disk_list="$stor_disks"
[ -n "$all_disks_flag" ] && test_disk_list_num="$(($stor_disks_num+$sys_disks_num))" || test_disk_list_num="$stor_disks_num"

expanders=$(sg_map -x | awk '{if ( $6 == 13 ) { print $1 }}'| tr '\n' ' ')
[ -z "$expanders" ] && echo "t:storage: Disks expander(s) not found"
[ -n "$expanders" -a -z "$stor_disks" ] && echo "t:storage: Disks expander(s) found but no disks in storage"

flush_storage_configuration()
{
	mdadm -S `ls /dev/md* 2>/dev/null` 2>/dev/null || :
	for D in "$test_disk_list"; do  
		mdadm --zero-superblock $D 2>/dev/null || :
	done
}

light_down_slots()
{
for e in $expanders; do
	for i in `seq 1 $(sg_ses -p 0xA $e | grep 'Element index' | wc -l)`; do  
				sg_ses --index="$i" --set=2:1=0 "$e" 2>/dev/null ||:
				sg_ses --index="$i" --set=3:5=0 "$e" 2>/dev/null ||:
	done
done
}

get_slot()
{
for e in $expanders; do
  sas_addr=$(lsscsi -tg | grep -w $1 | sed -n 's/.*sas:\(0x[0-9a-f]*\) .*/\1/p')
  slot=$(sg_ses -p 0xA $e | grep "$sas_addr" -B 8 | sed -n 's/.*Element index: \([0-9]\)/\1/p')
  if [ -n "$slot" ]; then 
		printf "slot=$slot; expander=$e"
    break
  fi  
done
}

light_up_slot()
{
case "$1" in
	failed) sg_str='3:5' ;;
	passed) sg_str='2:1' ;;
esac

eval `get_slot $2`
sg_ses --index="$slot" --set=$sg_str=1 "$expander" 2>/dev/null ||: 
}

[ -n "$flush_storage_conf_flag" ] && flush_storage_configuration

[ -z "$expanders" ] || light_down_slots

check_drive_type()
{
	if [ "$(cat /sys/block/$1/queue/rotational 2>/dev/null||:)" -eq 1 ]; then
		printf "drive_type=sata-hdd"
	else
		printf "drive_type=ssd"
	fi
}

check_log()
{
	inotifywait -q -m -e modify /var/log/messages | while read foo; do
		if grep -E -q "(mpt2sas.*removing handle.*|mpt2sas.*log_info\(0x[0-9A-F]*\)|end_request: I/O error, dev sd)" /var/log/messages; then
			disk_err="$(cat /var/log/messages | cut -d ']' -f2- | sort -u | sed -n 's/.*end_request: I\/O error, dev \(sd[a-z]*\),.*/\1/p')"
			
			[ -n "$expanders" ] && phy_err="$(cat /var/log/messages | cut -d ']' -f2- | sort -u | sed -n 's,.*mpt2sas.*log_info(\(0x[0-9A-F]*\)).*code(\(0x[0-9A-F]*\)).*sub_code(\(0x[0-9A-F]*\)).*,\1\,\2\,\3\n,p')"
			[ -n "$expanders" ] && disk_missing_err="$(cat /var/log/messages | cut -d ']' -f2- | sort -u | sed -n 's,.*mpt2sas.*removing handle.*sas_addr(\(0x[0-9A-F]*\)).*,\1,p')"
			[ -n "$disk_missing_err" ] && disk_missing=$(check_empty_slots | grep -v "$empty_slots")
			[ -n "$disk_missing" ] && echo "t:storage: Disk fires back during test in slot: $disk_missing" 2>&1 | tee -a $logfile
			[ -n "$disk_err" -a -z "$phy_err" ] && echo "t-storage: I/O errors on $disk_err" 2>&1 | tee -a $logfile
			[ -n "$disk_err" -a -n "$phy_err" ] &&  echo "t-storage: Errors on physical layer of $disk_err; log_info,code,sub_code: $phy_err" 2>&1 | tee -a $logfile
		else
			continue
		fi
	done
}

check_empty_slots()
{
	if [ -n "$expanders" ]; then 
		for e in $expanders; do
#TODO Prepare parameters and values to better usage in check_storage_disks_num
			#empty_slots="$(sg_ses -p 0xA $e | grep 0x0000000000000000 -B 8 | sed -n 's/.*Element index: \([0-9]\)/\1/p;s/\n' | tr '\n' ',' | sed 's/\,$//g' )"
			empty_slots="$(sg_ses -p 0xA $e | grep 0x0000000000000000 -B 8 | sed -n 's/.*Element index: \([0-9]\)/\1/p' | tr '\n' ',' | sed 's/\,$//g')"
		done
		printf "$empty_slots\n"
	fi
}

check_storage_disks_num()
{
	if [ -n "$stor_disks_num" ]; then 
		[ "$stor_disks_num" -eq "$ref_stor_disks_num" ] || { 
			echo "t:storage: Number of disks in storage is $stor_disks_num, that is less than $ref_stor_disks_num. Empty slots: $(check_empty_slots)" 2>&1 | tee -a $logfile; }
	else

		for i in $(seq 0 10); do
			if $(h-lsdev | grep -q /dev/ses$i); then
				dev=$(h-lsdev | grep /dev/ses$i | cut -f 1 -d ' ')
				num=$(for i in `seq 1 128`; do
					if sg_ses -I $i $dev | grep -q ">>> no match on"; then
						echo $i
						break
					fi
				done
				);

				for j in `seq  1 $num`; do
					if ! h-lsdev | grep -q /dev/das:$i:$j; then
						echo -n "$i:$(expr $j - 1) "
						sg_ses -I $(expr $j - 1) -S fault $dev
					fi
				done
			fi
		done

	fi
}

send_results()
{
	RESULTS="&IOPS_${device}_${method}_${mode}=${IOPS}&latency_${device}_${method}_${mode}=${latency}&bandwidth_${device}_${method}_${mode}=${bandwidth}"
	curl "$API_URL?srv_id=$srv_id$RESULTS" || echo "Can't send current state to ya-hw-test!"
}

#TODO
#human_readable_format()
#{
#	if [ "$1" -ge 60 -a "$1" -lt 3600 ]; then
#		printf "$(($1/60))h"
#	ifelse 
#		[ "$1" -ge 3600 ] && printf "$(($1/3600))h"
#	else
#		printf "$1s"
#	fi
#}

run_fio_job()
{
									fio $conf_file  > $log_file || { rc=$?; echo  "t:storage: Failed to start fio"; }
									check_fio_results ${dev_disk#/dev/} ${log_file} || rc=$?
}
									
run_fio()
{
if [ -n "$stor_disks" -a "$device_list" = "disk" ]; then
	mode_multiplier=$(printf "mode_list" | wc -w)
	method_multiplier=$(printf "method_list" | wc -w)
	test_duration=$(($stor_disks_num*$stor_test_time${mode_multiplier:+*$mode_multiplier}${method_multiplier:+*$method_multiplier} + $sys_disks_num*$sys_test_time${mode_multiplier:+*$mode_multiplier}${method_multiplier:+*$method_multiplier}))
else
	test_duration=$(($sys_disks_num*$sys_test_time${mode_multiplier:+*$mode_multiplier}${method_multiplier:+*$method_multiplier}))
fi

# TODO: Human readable format (see upper function)
echo "t:storage: Expected duration of the test is ${test_duration}s"

	for device in $device_list; do
		for method in $method_list; do
			for mode in $mode_list; do
				mode_name="${method}${mode}"

				if [ "$method" = "rand" ]; then
					io_depth=$io_ran_depth
				else 
					io_depth=$io_seq_depth
					mode_name=$mode
				fi

#		if [ -n "$hard_raid" ]; then
#			sudo ./MegaCli64 -CfgClr -aAll
#			# RAID10:
#			for enc in $(MegaCli64 -PDList -aAll | sed -n 's/Enclosure Device ID: \([0-9]*\)/\1/p' | sort -u); do
#				n=0
#				array_devs=
#				for dev in `seq 1 2 $(($(MegaCli64 -PDList -aAll | grep -C 1 "Enclosure Device ID: $enc" | 
#					grep 'Slot Number' | cut -d ' ' -f 3 | wc -l)-1))`; do 
#						dev_pair=$((dev+1))
#						array_devs="${array_devs}Array$n[$enc:$dev,$enc:$dev_pair] "
#						n=$((n+1))
#				done
#			done
#			MegaCli64 -CfgSpanAdd $raid_level $array_devs -a0
#			MegaCli64 -LDInit -Start full -l0 -a0
#			MegaCli -LDInit ShowProg -l0 -a0
#		fi

				dev_filenames=''

				if [ -n "$(printf "$device" | sed -n '/^raid/p')" ]; then
					dev_raid=/dev/md0
					raid_level="$(printf $device | sed -n 's/^[a-z]*\([0-9]*\)/\1/p')"
					conf_file="$tmp_dir/${method}_${mode}_${device}.conf"
					log_file="$tmp_dir/${method}_${mode}_${device}.log"

					if [ "$stor_disks_num" -gt 24 ]; then
					disks_from=1
					[ -n "dev_raid_num" ] || dev_raid_num=20
					dev_raids=''
						for G in `seq $(($stor_disks_num/$dev_raid_num))`; do
							dev_raid="/dev/md$(($G-1))"
							disks_to=$(($G*$dev_raid_num+1))
							disks_part=$(lsscsi -tg | grep sas | sed -n '$disks_from,$disks_to{s,.*\(/dev/sd[a-z]*\),\1,p}' | tr '\012' ' ')
							disks_from=$(($disks_to+1));
							mdadm --create $dev_raid --level=$raid_level --raid-devices=$dev_raid_num "$disks_part"
							dev_raids="$([ -n "$dev_raids" ] && printf "$dev_raids ")$dev_raid"
							dev_filenames=$(printf "${dev_filenames:+$dev_filenames\n }filename=$dev_raid")
						done
						mdadm -W $dev_raids
					else
						dev_raids=$dev_raid
						mdadm --create $dev_raids --level=$raid_level --raid-devices=$stor_disks_num $disks
						mdadm -W $dev_raids
					fi
					dev_filenames="filename=$dev_raid"
				cat > "$conf_file" <<EOF
[$mode/test]
filename=$dev_raid
rw=$mode_name
direct=$direct
buffered=$buffered
ioengine=$io_engine
iodepth=$io_depth
runtime=$test_duration
EOF

							run_fio_job $conf_file $log_file

				else

					dev_filenames=$(printf "$test_disk_list" | tr '\n' ' ')

						dev_group_count=0

						if [ "$method" = "rand" ]; then
							dev_group_dim=$dev_group_dim_rand
						else 
							dev_group_dim=$dev_group_dim_seq
						fi

						dev_group_num=$((test_disk_list_num/$dev_group_dim))
						echo "DEBUG: $dev_group_num"
						while [ $dev_group_count -lt $dev_group_num ]; do
							echo "DEBUG: $dev_group_count"
							dev_group=$(printf $dev_filenames | cut -d ' ' -f $((dev_group_count*$dev_group_dim+1))-$(((dev_group_count+1)*$dev_group_dim)))
							echo "DEBUG: $dev_group"
							for dev_disk in $dev_group; do
								operation_runtime=$sys_test_time
								if [ $(echo "$stor_disks" | grep -qF "$dev_disk") ]; then
									[ -n "$opt_test_duration" ] || operation_runtime=$stor_test_time
								fi
								conf_file="$tmp_dir/${method}_${mode}_${device}_${dev_disk#/dev/}.conf"
								log_file="$tmp_dir/${method}_${mode}_${device}_${dev_disk#/dev/}.log"
								cat > "$conf_file" <<EOF
[$mode/test]
filename=$dev_disk
rw=$mode_name
direct=$direct
buffered=$buffered
ioengine=$io_engine
iodepth=$io_depth
runtime=$operation_runtime
EOF
							
									run_fio $conf_file $log_file &
									printf "$! " >> $jpid_file
									
									#[ -n "$VALIDATION" ] && { RESULTS=''; send_results; }

								done
						done
						wait $(cat $jpid_file) || rc=$?

			fi
				

			done
		done

		[ -n "$expanders" ] && check_storage_disks_num
		[ -n "$non_first_cycle" ] && flush_storage_configuration

		non_first_cycle=1

	done

	kill -9 $(cat $ipid_file) $(cat $tpid_file) >/dev/null 2>&1 ||:
	return $rc
}

check_fio_results()
{
		#log_file="$2"
		#[ "$mode" = "read" ] && log_part="head -1" || log_part="tail -1"
		#export $(printf "latency_raw_$mode")=$(cat $log_file | sed -n 's/.*clat (\([a-z]*\)).*avg=\([0-9]*.[0-9]*\),.*/\2\1/p' | $log_part)

		#latency_raw=$(cat $log_file | sed -n 's/.*clat (\([a-z]*\)).*avg=\([0-9]*.[0-9]*\),.*/\2\1/p' | $log_part)
		latency_read=
		latency_write=

		latency_raw=$(cat $log_file | sed -n 's/.*clat (\([a-z]*\)).*avg=\([0-9]*.[0-9]*\),.*/\2\1/p' )
		latency_value=$(printf "$latency_raw" | cut -d '.' -f 1)
		latency_unit=$(printf "$latency_raw" | tr -d '.[0-9]')
#		export $(printf "latency_raw_$mode")=$latency_raw
#		export $(printf "latency_value_$mode")=$latency_value
#		export $(printf "latency_unit_$mode")=$latency_unit

# latency_raw_read=$(cat $log_file | sed -n 's/.*clat (\([a-z]*\)).*avg=\([0-9]*.[0-9]*\),.*/\2\1/p' | head  -1)
# latency_unit_read=$(printf $latency_raw_read | tr -d [0-9])
# latency_value_read=$(printf $latency_raw_read | tr -d [:umsec:] | cut -d '.' -f 1)
# latency_raw_write=$(cat $log_file | sed -n 's/.*clat (\([a-z]*\)).*avg=\([0-9]*.[0-9]*\),.*/\2\1/p' | tail  -1)
# latency_unit_write=$(printf $latency_raw_write | tr -d [0-9])
# latency_value_write=$(printf $latency_raw_write | tr -d [:umsec:] | cut -d '.' -f 1)

#		case "$latency_unit" in
#				usec) export $(printf "latency_$mode")=$latency_value ;;
#				msec) export $(printf "latency_$mode")=$((latency_value * 60)) ;;
#				sec) export $(printf "latency_$mode")=$((latency_value * 3600)) ;;
#		esac

		case "$latency_unit" in
				usec) export $(printf "latency_$mode")=$latency_value ;;
				msec) export $(printf "latency_$mode")=$((latency_value * 60)) ;;
				sec) export $(printf "latency_$mode")=$((latency_value * 3600)) ;;
		esac

	IOPS=$(cat $log_file | sed -n 's/.*iops=\([0-9]*\).*/\1/p' | head -1)

	bandwidth_raw=$(cat $log_file | sed -n 's/.*bw=\([0-9]*.*\)\/s, iops.*/\1/p' | head -1 )
	bandwidth_unit="$(printf "$bandwidth_raw" | tr -d [0-9])"
	bandwidth_value="$(printf "$bandwidth_raw" | tr -d [GMKB] | cut -d '.' -f 1)"
		case "$bandwidth_unit" in
				B) bandwidth="$bandwidth_value" ;;
				KB) bandwidth="$((bandwidth_value * 1024))" ;;
				MB) bandwidth="$((bandwidth_value * 1048576))" ;;
				GB) bandwidth="$((bandwidth_value * 1073741824))" ;;
		esac
	
	echo "t:storage: $conf_file, IOPS=$IOPS, ${latency_read:+latency(read)=${latency_raw}, }${latency_write:+latency(write)=$latency_raw, }bandwidth=$bandwidth_raw/s"

	[ -n "$stor_disks" ] && {
			ref_iops=$ref_iops_all
			ref_latency_read=$ref_latency_read_all
			ref_latency_write=$ref_latency_write_all
			ref_bandwidth=$ref_bandwidth_all
		} || {
			ref_iops=$ref_iops_sys
			ref_latency_read=$ref_latency_read_sys
			ref_latency_write=$ref_latency_write_sys
			ref_bandwidth=$ref_bandwidth_sys
		}

			[ "$IOPS" -lt "$ref_iops" ] && {
				rc=2; echo "t:storage: Low IOPS on disk operations: $IOPS!" 2>&1 | tee -a $logfile
			}

			[ -z $latency_read ] || {
				[ "$latency_read" -gt "$ref_latency_read" ] && {
					rc=3; echo "t:storage: Latency(read) is to high: $latency_raw_read!" 2>&1 | tee -a $logfile
				}
			}

			[ -z $latency_write ] || {
				[ "$latency_write" -gt "$ref_latency_write" ] && {
					rc=3; echo "t:storage: Latency(write) is to high: $latency_raw_write!" 2>&1 | tee -a $logfile
				}
			}

			[ "$bandwidth" -lt "$ref_bandwidth" ] && {
				rc=4; echo "t:storage: The I/O bandwidth is to low: $bandwidth!" 2>&1 | tee -a $logfile
			}
	return $rc
}

run_badblocks()
{
	timeout -k 5 $opt_test_duration badblocks -wv -b 512 -e 3 -s -t 0xff -o $(printf "$bad_block_list"."$$" | tee -a $bad_disks_list) $d 2>&1 || rc=$?
	bpid=$!
	printf "$bpid " >> $fpid_file
	wait $bpid || rc=$?
		# RC: 127 for timeout and 1? for pass
		if [ "$rc" -ne 0 -a "$rc" -ne 127 ]; then
				echo "badblocks ended with RC: $rc"
				light_up_slot failed $d
		fi  
#	[ -n "$send_results" ] && curl -v -g -d "STAGE=2&RESULT=FAILED&REASON=BBLOCK_FAILED&$data" "$api_url"
#	[ -n "$send_results" ] && curl -v -d "RESULT=VALID&$data" "$SERVER"

	return 0
}

run_badblocks_check()
{
	rc=0
	for d in $test_disk_list; do
		run_badblocks &
	done

	sleep $((opt_test_duration+5))
	[ ! -n "$(cat $bad_block_list''* ||:)" ] || echo "t:storage: disks has bad blocks: $(cat $bad_block_list''* ||:)" | tee -a $logfile

	kill -9 $(cat $ipid_file) $(cat $tpid_file) >/dev/null 2>&1 ||:
	return $rc 
}

hdd_temp_measurement()
{
	cur_hdd_temp=$(smartctl -a $1 | grep Temperature_Celsius | awk '{print $10}');
	[ "$cur_hdd_temp" -ge "$warn_hdd_temp" ] && echo "$1(S/N:$(smartctl -a $1 | sed -ne 's/^Serial Number: *\(.*\)/\1/p'), $(get_slot) ) temperature is high: $cur_hdd_temp°C"
	[ "$cur_hdd_temp" -ge "$max_hdd_temp" ] && \
	{ kill -9  $(cat $ipid_file) $(cat $fpid_file) >/dev/null 2>&1 || rc=$?; echo "$1(S/N:$(smartctl -a $1 | sed -ne 's/^Serial Number: *\(.*\)/\1/p'), $(get_slot) ) temperature is CRITICAL: $cur_hdd_temp°C"; exit $rc; }
}

hdd_temp_check()
{
	while :; do
		for dev_disk in $test_disk_list; do
			hdd_temp_measurement $dev_disk &
			printf "$([ -s "$tpid_file" ] && printf " ")$?" >> tpid_file 
		done
		sleep 5
	done
}

echo "t:storage: VERSION $VERSION"

[ -n "$expanders" ] && check_storage_disks_num

check_log &
ipid=$!
printf "$ipid" > $ipid_file

hdd_temp_check &
tpid=$!
printf "$tpid" > $tpid_file

for test in $opt_tests; do
	rc=0
	echo $test > /var/run/current-load
	echo "t:storage: Starting $test test..."
	case $test in
		fio)
			run_fio &
			fpid=$!
			printf $fpid > $fpid_file
		;;
		badblocks)
			run_badblocks_check &
			fpid=$!
			printf $fpid > $fpid_file
		;;
	esac

done

wait "$ipid" "$fpid" ||:

[ ! -s "$logfile" -a ! -s "${bad_block_list}*" ] || 
	echo "t:storage: FAILED! $(cat $logfile | cut -d ' ' -f 3- | uniq | tr '\n' '; ';
		[ ! -s "$bad_disks_list" ] || for list in $(cat $bad_disks_list); do \
			[ -s "$list" ] && cat $list | cut -d ' ' -f 3- | tr '\n' '; ' ||: 
		done)"

exit
